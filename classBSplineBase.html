<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EOL BSpline Library: BSplineBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EOL BSpline Library
   &#160;<span id="projectnumber">v2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classBSplineBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BSplineBase&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="BSplineBase_8h_source.html">BSplineBase.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BSplineBase&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classBSplineBase.png" usemap="#BSplineBase_3C_20T_20_3E_map" alt=""/>
  <map id="BSplineBase_3C_20T_20_3E_map" name="BSplineBase_3C_20T_20_3E_map">
<area href="classBSpline.html" alt="BSpline&lt; T &gt;" shape="rect" coords="0,56,114,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5e748cf066e66d178717673ec04400bb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bb">BoundaryConditionTypes</a> { <a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bbab2cbe9b650cf1b47b98aeef19ddc81a0">BC_ZERO_ENDPOINTS</a> = 0
, <a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bba73e5ec93ff720eff69ebc922e0adbf98">BC_ZERO_FIRST</a> = 1
, <a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bbabe606d289277b3422eb8928803f55dbd">BC_ZERO_SECOND</a> = 2
 }</td></tr>
<tr class="separator:a5e748cf066e66d178717673ec04400bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4bbfe6bd296faa4751dcf73b90ccf0"><td class="memItemLeft" align="right" valign="top"><a id="aba4bbfe6bd296faa4751dcf73b90ccf0"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>datum_type</b></td></tr>
<tr class="separator:aba4bbfe6bd296faa4751dcf73b90ccf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7e23fd18ea3f194d179d6da62a59c6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#ac7e23fd18ea3f194d179d6da62a59c6d">BSplineBase</a> (const T *x, int nx, double wl, int bc_type=<a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bbabe606d289277b3422eb8928803f55dbd">BC_ZERO_SECOND</a>, int num_nodes=0)</td></tr>
<tr class="separator:ac7e23fd18ea3f194d179d6da62a59c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8f0b5c6fa2cc45e2c3c189ff868be4"><td class="memItemLeft" align="right" valign="top"><a id="aff8f0b5c6fa2cc45e2c3c189ff868be4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#aff8f0b5c6fa2cc45e2c3c189ff868be4">BSplineBase</a> (const <a class="el" href="classBSplineBase.html">BSplineBase</a> &amp;bb)</td></tr>
<tr class="memdesc:aff8f0b5c6fa2cc45e2c3c189ff868be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:aff8f0b5c6fa2cc45e2c3c189ff868be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa692681d1da2f8bb103dcd76175b0135"><td class="memItemLeft" align="right" valign="top"><a id="aa692681d1da2f8bb103dcd76175b0135"></a>
<a class="el" href="classBSplineBase.html">BSplineBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#aa692681d1da2f8bb103dcd76175b0135">operator=</a> (const <a class="el" href="classBSplineBase.html">BSplineBase</a> &amp;right)</td></tr>
<tr class="memdesc:aa692681d1da2f8bb103dcd76175b0135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:aa692681d1da2f8bb103dcd76175b0135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf18fd5d8fd0c0723fe8ef688a9d220f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f">setDomain</a> (const T *x, int nx, double wl, int bc_type=<a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bbabe606d289277b3422eb8928803f55dbd">BC_ZERO_SECOND</a>, int num_nodes=0)</td></tr>
<tr class="separator:acf18fd5d8fd0c0723fe8ef688a9d220f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5cedde9516de8d3d70502b93377469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBSpline.html">BSpline</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469">apply</a> (const T *y)</td></tr>
<tr class="separator:a8b5cedde9516de8d3d70502b93377469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa348e90f54e237276bf0947da927cd24"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#aa348e90f54e237276bf0947da927cd24">nodes</a> (int *nnodes)</td></tr>
<tr class="separator:aa348e90f54e237276bf0947da927cd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac749628a10c09afa9593c4315d9d1a75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#ac749628a10c09afa9593c4315d9d1a75">nNodes</a> ()</td></tr>
<tr class="separator:ac749628a10c09afa9593c4315d9d1a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6a533b72487d286fe610882db05528"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a7b6a533b72487d286fe610882db05528">nX</a> ()</td></tr>
<tr class="separator:a7b6a533b72487d286fe610882db05528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6f2b2080c68b79e40a40fafa44636c"><td class="memItemLeft" align="right" valign="top"><a id="a6f6f2b2080c68b79e40a40fafa44636c"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a6f6f2b2080c68b79e40a40fafa44636c">Xmin</a> ()</td></tr>
<tr class="memdesc:a6f6f2b2080c68b79e40a40fafa44636c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum x value found. <br /></td></tr>
<tr class="separator:a6f6f2b2080c68b79e40a40fafa44636c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3002c6ef83126236e1a2ff6a8995293"><td class="memItemLeft" align="right" valign="top"><a id="ad3002c6ef83126236e1a2ff6a8995293"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#ad3002c6ef83126236e1a2ff6a8995293">Xmax</a> ()</td></tr>
<tr class="memdesc:ad3002c6ef83126236e1a2ff6a8995293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum x value found. <br /></td></tr>
<tr class="separator:ad3002c6ef83126236e1a2ff6a8995293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3d3ee0e5cd4dc93758d25a6bd9f941"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#abc3d3ee0e5cd4dc93758d25a6bd9f941">Alpha</a> (double wavelength)</td></tr>
<tr class="separator:abc3d3ee0e5cd4dc93758d25a6bd9f941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd4453e84abfc323fb1e9ce9bc47308"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a2cd4453e84abfc323fb1e9ce9bc47308">Alpha</a> ()</td></tr>
<tr class="separator:a2cd4453e84abfc323fb1e9ce9bc47308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cd42e86d06c2fcd56d422cca33ec54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok</a> ()</td></tr>
<tr class="separator:aa1cd42e86d06c2fcd56d422cca33ec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0f101eb05135df237d55f2d07647a045"><td class="memItemLeft" align="right" valign="top"><a id="a0f101eb05135df237d55f2d07647a045"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a0f101eb05135df237d55f2d07647a045">Version</a> ()</td></tr>
<tr class="memdesc:a0f101eb05135df237d55f2d07647a045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing the bspline library version. <br /></td></tr>
<tr class="separator:a0f101eb05135df237d55f2d07647a045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6219fc2b912a7fe31bcbb2f06dace4f8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a6219fc2b912a7fe31bcbb2f06dace4f8">Debug</a> (int on=-1)</td></tr>
<tr class="separator:a6219fc2b912a7fe31bcbb2f06dace4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a427b8861aed5102ac9a621211291ce1d"><td class="memItemLeft" align="right" valign="top"><a id="a427b8861aed5102ac9a621211291ce1d"></a>
typedef <a class="el" href="structBSplineBaseP.html">BSplineBaseP</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>
<tr class="separator:a427b8861aed5102ac9a621211291ce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8910fa43321182d1dbc192422f0d7518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a8910fa43321182d1dbc192422f0d7518">Setup</a> (int num_nodes=0)</td></tr>
<tr class="memdesc:a8910fa43321182d1dbc192422f0d7518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup number of nodes and deltax for the given domain and cutoff wavelength.  <a href="classBSplineBase.html#a8910fa43321182d1dbc192422f0d7518">More...</a><br /></td></tr>
<tr class="separator:a8910fa43321182d1dbc192422f0d7518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487ad3598cbc9c75286e276ca13a8170"><td class="memItemLeft" align="right" valign="top"><a id="a487ad3598cbc9c75286e276ca13a8170"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateQ</b> ()</td></tr>
<tr class="separator:a487ad3598cbc9c75286e276ca13a8170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ccf8bcfd237d1d2f663ee755c06c39"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a86ccf8bcfd237d1d2f663ee755c06c39">qDelta</a> (int m1, int m2)</td></tr>
<tr class="separator:a86ccf8bcfd237d1d2f663ee755c06c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae444b1b403cf909503985d6e00cc1a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a5ae444b1b403cf909503985d6e00cc1a">Beta</a> (int m)</td></tr>
<tr class="separator:a5ae444b1b403cf909503985d6e00cc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d41f0a26f4dd433f07b7a9bb73a7d9"><td class="memItemLeft" align="right" valign="top"><a id="a07d41f0a26f4dd433f07b7a9bb73a7d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addP</b> ()</td></tr>
<tr class="separator:a07d41f0a26f4dd433f07b7a9bb73a7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fc1340f983afc5f1238183ae01f047"><td class="memItemLeft" align="right" valign="top"><a id="a03fc1340f983afc5f1238183ae01f047"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>factor</b> ()</td></tr>
<tr class="separator:a03fc1340f983afc5f1238183ae01f047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5171903e7037da186a72eb636f7f537f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a5171903e7037da186a72eb636f7f537f">Basis</a> (int m, T x)</td></tr>
<tr class="separator:a5171903e7037da186a72eb636f7f537f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa64f1458530f4c64973f22425017fcc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#aaa64f1458530f4c64973f22425017fcc">DBasis</a> (int m, T x)</td></tr>
<tr class="separator:aaa64f1458530f4c64973f22425017fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6d8472188c5905a75da0a80770a3e4"><td class="memItemLeft" align="right" valign="top"><a id="afd6d8472188c5905a75da0a80770a3e4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Ratiod</b> (int &amp;, double &amp;, double &amp;)</td></tr>
<tr class="separator:afd6d8472188c5905a75da0a80770a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae6832f21d9950b7490e68958bd6ad5bf"><td class="memItemLeft" align="right" valign="top"><a id="ae6832f21d9950b7490e68958bd6ad5bf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>waveLength</b></td></tr>
<tr class="separator:ae6832f21d9950b7490e68958bd6ad5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fd723695cc2bde8661cf46b153fe6d"><td class="memItemLeft" align="right" valign="top"><a id="a66fd723695cc2bde8661cf46b153fe6d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NX</b></td></tr>
<tr class="separator:a66fd723695cc2bde8661cf46b153fe6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccf27ca1d01311a750e110c116a2b11"><td class="memItemLeft" align="right" valign="top"><a id="afccf27ca1d01311a750e110c116a2b11"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>K</b></td></tr>
<tr class="separator:afccf27ca1d01311a750e110c116a2b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c09cb70f97ea7d20f3c1c1d5d1a7a9"><td class="memItemLeft" align="right" valign="top"><a id="a61c09cb70f97ea7d20f3c1c1d5d1a7a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>BC</b></td></tr>
<tr class="separator:a61c09cb70f97ea7d20f3c1c1d5d1a7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8307df0a8c77af9a170df6e3d84d79"><td class="memItemLeft" align="right" valign="top"><a id="a8f8307df0a8c77af9a170df6e3d84d79"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>xmax</b></td></tr>
<tr class="separator:a8f8307df0a8c77af9a170df6e3d84d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21657827a3d04f10bc91327257471a49"><td class="memItemLeft" align="right" valign="top"><a id="a21657827a3d04f10bc91327257471a49"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>xmin</b></td></tr>
<tr class="separator:a21657827a3d04f10bc91327257471a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514d1d6c3485a3bba14c7ca510a27b48"><td class="memItemLeft" align="right" valign="top"><a id="a514d1d6c3485a3bba14c7ca510a27b48"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>M</b></td></tr>
<tr class="separator:a514d1d6c3485a3bba14c7ca510a27b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a0519d5fa682418b2c7649d6d90202"><td class="memItemLeft" align="right" valign="top"><a id="a71a0519d5fa682418b2c7649d6d90202"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>DX</b></td></tr>
<tr class="separator:a71a0519d5fa682418b2c7649d6d90202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea8c9049ed48f8a8ac54adecd18bc8e"><td class="memItemLeft" align="right" valign="top"><a id="a1ea8c9049ed48f8a8ac54adecd18bc8e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>alpha</b></td></tr>
<tr class="separator:a1ea8c9049ed48f8a8ac54adecd18bc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ccb2b06841f543d7312cdc564e02c3"><td class="memItemLeft" align="right" valign="top"><a id="af3ccb2b06841f543d7312cdc564e02c3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>OK</b></td></tr>
<tr class="separator:af3ccb2b06841f543d7312cdc564e02c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a021fda1885d6b5885f9d310ed796d"><td class="memItemLeft" align="right" valign="top"><a id="aa1a021fda1885d6b5885f9d310ed796d"></a>
std::unique_ptr&lt; <a class="el" href="structBSplineBaseP.html">Base</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>base</b></td></tr>
<tr class="separator:aa1a021fda1885d6b5885f9d310ed796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a7857ee42bae59319f95a7baca5be814e"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a7857ee42bae59319f95a7baca5be814e">BoundaryConditions</a> [3][4]</td></tr>
<tr class="separator:a7857ee42bae59319f95a7baca5be814e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab1978db3ff075dcc92a003830bde99"><td class="memItemLeft" align="right" valign="top"><a id="a0ab1978db3ff075dcc92a003830bde99"></a>
static const double&#160;</td><td class="memItemRight" valign="bottom"><b>PI</b> = 3.1415927</td></tr>
<tr class="separator:a0ab1978db3ff075dcc92a003830bde99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class BSplineBase&lt; T &gt;</h3>

<p>The base class for a spline object containing the nodes for a given domain, cutoff wavelength, and boundary condition.</p>
<p>To smooth a single curve, the <a class="el" href="classBSpline.html">BSpline</a> interface contains a constructor which both sets up the domain and solves for the spline. Subsequent curves over the same domain can be created by <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469">apply()</a>ing them to the <a class="el" href="classBSpline.html">BSpline</a> object, where <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469">apply()</a> is a <a class="el" href="classBSplineBase.html">BSplineBase</a> method. [See <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469">apply()</a>.] New curves can also be smoothed within the same <a class="el" href="classBSpline.html">BSpline</a> object by calling solve() with the new set of y values. [See <a class="el" href="classBSpline.html">BSpline</a>.] A <a class="el" href="classBSplineBase.html">BSplineBase</a> can be created on its own, in which case all of the computations dependent on the x values, boundary conditions, and cutoff wavelength have already been completed.</p>
<p>The solution of the cubic b-spline is divided into two parts. The first is the setup of the domain given the x values, boundary conditions, and wavelength. The second is the solution of the spline for a set of y values corresponding to the x values in the domain. The first part is done in the creation of the <a class="el" href="classBSplineBase.html">BSplineBase</a> object (or when calling the setDomain method). The second part is done when creating a <a class="el" href="classBSpline.html">BSpline</a> object (or calling solve() on a <a class="el" href="classBSpline.html">BSpline</a> object).</p>
<p>A <a class="el" href="classBSpline.html">BSpline</a> object can be created with either one of its constructors, or by calling <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469">apply()</a> on an existing <a class="el" href="classBSplineBase.html">BSplineBase</a> object. Once a spline has been solved, it can be evaluated at any x value. The following example creates a spline curve and evaluates it over the domain:</p>
<pre class="fragment">    vector&lt;float&gt; x;
    vector&lt;float&gt; y;
    { ... }
    int bc = BSplineBase&lt;float&gt;::BC_ZERO_SECOND;
    BSpline&lt;float&gt;::Debug = true;
    BSpline&lt;float&gt; spline (x.begin(), x.size(), y.begin(), wl, bc);
    if (spline.ok())
    {
        ostream_iterator&lt;float&gt; of(cout, "\t ");
        float xi = spline.Xmin();
    float xs = (spline.Xmax() - xi) / 2000.0;
    for (; xi &lt;= spline.Xmax(); xi += xs)
    {
        *of++ = spline.evaluate (xi);
    }
    }</pre><p>In the usual usage, the <a class="el" href="classBSplineBase.html">BSplineBase</a> can compute a reasonable number of nodes for the spline, balancing between a few desirable factors. There needs to be at least 2 nodes per cutoff wavelength (preferably 4 or more) for the derivative constraint to reliably approximate a lo-pass filter. There should be at least 1 and preferably about 2 data points per node (measured just by their number and not by any check of the density of points across the domain). Lastly, of course, the fewer the nodes then the faster the computation of the spline. The computation of the number of nodes happens in the <a class="el" href="classBSplineBase.html#a8910fa43321182d1dbc192422f0d7518" title="Setup number of nodes and deltax for the given domain and cutoff wavelength.">Setup()</a> method during <a class="el" href="classBSplineBase.html">BSplineBase</a> construction and when <a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f">setDomain()</a> is called. If the setup fails to find a desirable number of nodes, then the <a class="el" href="classBSplineBase.html">BSplineBase</a> object will return false from <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a>.</p>
<p>The <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a> method returns false when a <a class="el" href="classBSplineBase.html">BSplineBase</a> or <a class="el" href="classBSpline.html">BSpline</a> could not complete any operation successfully. In particular, as mentioned above, <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a> will return false if some problem was detected with the domain values or if no reasonable number of nodes could be found for the given cutoff wavelength. Also, <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a> on a <a class="el" href="classBSpline.html">BSpline</a> object will return false if the matrix equation could not be solved, such as after <a class="el" href="classBSpline.html">BSpline</a> construction or after a call to <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469">apply()</a>.</p>
<p>If letting <a class="el" href="classBSplineBase.html#a8910fa43321182d1dbc192422f0d7518" title="Setup number of nodes and deltax for the given domain and cutoff wavelength.">Setup()</a> determine the number of nodes is not acceptable, the constructors and <a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f">setDomain()</a> accept the parameter num_nodes. By default, num_nodes is passed as zero, forcing <a class="el" href="classBSplineBase.html#a8910fa43321182d1dbc192422f0d7518" title="Setup number of nodes and deltax for the given domain and cutoff wavelength.">Setup()</a> to calculate the number of nodes. However, if num_nodes is passed as 2 or greater, then <a class="el" href="classBSplineBase.html#a8910fa43321182d1dbc192422f0d7518" title="Setup number of nodes and deltax for the given domain and cutoff wavelength.">Setup()</a> will bypass its own algorithm and accept the given number of nodes instead. Obviously, it's up to the programmer to understand the affects of the number of nodes on the representation of the data and on the solution (or non-solution) of the spline. Remember to check the <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a> method to detect when the spline solution has failed.</p>
<p>The interface for the <a class="el" href="classBSplineBase.html">BSplineBase</a> and <a class="el" href="classBSpline.html">BSpline</a> templates is defined in the header file <a class="el" href="BSpline_8h_source.html">BSpline.h</a>. The implementation is defined in <a class="el" href="BSpline_8cpp.html">BSpline.cpp</a>. Source files which will instantiate the template should include the implementation file and <em>not</em> the interface. If the implementation for a specific type will be linked from elsewhere, such as a static library or Windows DLL, source files should only include the interface file. On Windows, applications should link with the import library BSpline.lib and make sure BSpline.dll is on the path. The DLL contains an implementation for BSpline&lt;float&gt; and BSpline&lt;double&gt;. For debugging, an application can include the implementation to get its own instantiation.</p>
<p>The algorithm is based on the cubic spline described by Katsuyuki Ooyama in Montly Weather Review, Vol 115, October 1987. This implementation has benefited from comparisons with a previous FORTRAN implementation by James L. Franklin, NOAA/Hurricane Research Division. In particular, the algorithm in the <a class="el" href="classBSplineBase.html#a8910fa43321182d1dbc192422f0d7518" title="Setup number of nodes and deltax for the given domain and cutoff wavelength.">Setup()</a> method is based mostly on his implementation (VICSETUP). The <a class="el" href="classBSplineBase.html#a8910fa43321182d1dbc192422f0d7518" title="Setup number of nodes and deltax for the given domain and cutoff wavelength.">Setup()</a> method finds a suitable default for the number of nodes given a domain and cutoff frequency. This implementation adopts most of the same constraints, including a constraint that the cutoff wavelength not be greater than the span of the domain values: wl &lt; max(x) - min(x). If this is not an acceptable constraint, then use the num_nodes parameter to specify the number of nodes explicitly.</p>
<p>The cubic b-spline is formulated as the sum of some multiple of the basis function centered at each node in the domain. The number of nodes is determined by the desired cutoff wavelength and a desirable number of x values per node. The basis function is continuous and differentiable up to the second degree. A derivative constraint is included in the solution to achieve the effect of a low-pass frequency filter with the given cutoff wavelength. The derivative constraint can be disabled by specifying a wavelength value of zero, which reduces the analysis to a least squares fit to a cubic b-spline. The domain nodes, boundary constraints, and wavelength determine a linear system of equations, Qa=b, where a is the vector of basis function coefficients at each node. The coefficient vector is solved by first LU factoring along the diagonally banded matrix Q in <a class="el" href="classBSplineBase.html">BSplineBase</a>. The <a class="el" href="classBSpline.html">BSpline</a> object then computes the B vector for a set of y values and solves for the coefficient vector with the LU matrix. Only the diagonal bands are stored in memory and calculated during LU factoring and back substitution, and the basis function is evaluated as few times as possible in computing the diagonal matrix and B vector.</p>
<dl class="section author"><dt>Author</dt><dd>Gary Granger (<a href="http://www.eol.ucar.edu/homes/granger">http://www.eol.ucar.edu/homes/granger</a>)</dd></dl>
<pre class="fragment">Copyright (c) 1998-2009
University Corporation for Atmospheric Research, UCAR
All rights reserved.
</pre> </div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5e748cf066e66d178717673ec04400bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e748cf066e66d178717673ec04400bb">&#9670;&nbsp;</a></span>BoundaryConditionTypes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bb">BSplineBase::BoundaryConditionTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Boundary condition types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e748cf066e66d178717673ec04400bbab2cbe9b650cf1b47b98aeef19ddc81a0"></a>BC_ZERO_ENDPOINTS&#160;</td><td class="fielddoc"><p>Set the endpoints of the spline to zero. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e748cf066e66d178717673ec04400bba73e5ec93ff720eff69ebc922e0adbf98"></a>BC_ZERO_FIRST&#160;</td><td class="fielddoc"><p>Set the first derivative of the spline to zero at the endpoints. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e748cf066e66d178717673ec04400bbabe606d289277b3422eb8928803f55dbd"></a>BC_ZERO_SECOND&#160;</td><td class="fielddoc"><p>Set the second derivative to zero. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac7e23fd18ea3f194d179d6da62a59c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e23fd18ea3f194d179d6da62a59c6d">&#9670;&nbsp;</a></span>BSplineBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::<a class="el" href="classBSplineBase.html">BSplineBase</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bc_type</em> = <code><a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bbabe606d289277b3422eb8928803f55dbd">BC_ZERO_SECOND</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a spline domain for the given set of x values, cutoff wavelength, and boundary condition type. The parameters are the same as for <a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f">setDomain()</a>. Call <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a> to check whether domain setup succeeded after construction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2cd4453e84abfc323fb1e9ce9bc47308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd4453e84abfc323fb1e9ce9bc47308">&#9670;&nbsp;</a></span>Alpha() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Alpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return alpha currently in use by this domain. </p>

</div>
</div>
<a id="abc3d3ee0e5cd4dc93758d25a6bd9f941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3d3ee0e5cd4dc93758d25a6bd9f941">&#9670;&nbsp;</a></span>Alpha() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Alpha </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the Alpha value for a given wavelength. Note that this depends on the current node interval length (DX).</p>
<p>Calculate the alpha parameter given a wavelength. </p>

</div>
</div>
<a id="a8b5cedde9516de8d3d70502b93377469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5cedde9516de8d3d70502b93377469">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBSpline.html">BSpline</a>&lt; T &gt; * <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classBSpline.html">BSpline</a> smoothed curve for the given set of NX y values. The returned object will need to be deleted by the caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The array of y values corresponding to each of the <a class="el" href="classBSplineBase.html#a7b6a533b72487d286fe610882db05528">nX()</a> x values in the domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a></dd></dl>
<p>Given an array of y data points defined over the domain of x data points in this <a class="el" href="classBSplineBase.html">BSplineBase</a>, create a <a class="el" href="classBSpline.html">BSpline</a> object which contains the smoothed curve for the y array. </p>

</div>
</div>
<a id="a5171903e7037da186a72eb636f7f537f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5171903e7037da186a72eb636f7f537f">&#9670;&nbsp;</a></span>Basis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Basis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Evaluate the closed basis function at node m for value x, using the parameters for the current boundary conditions. </p>

</div>
</div>
<a id="a5ae444b1b403cf909503985d6e00cc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae444b1b403cf909503985d6e00cc1a">&#9670;&nbsp;</a></span>Beta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Beta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the correct beta value given the node index. The value depends on the node index and the current boundary condition type. </p>

</div>
</div>
<a id="aaa64f1458530f4c64973f22425017fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa64f1458530f4c64973f22425017fcc">&#9670;&nbsp;</a></span>DBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::DBasis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Evaluate the deriviative of the closed basis function at node m for value x, using the parameters for the current boundary conditions. </p>

</div>
</div>
<a id="a6219fc2b912a7fe31bcbb2f06dace4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6219fc2b912a7fe31bcbb2f06dace4f8">&#9670;&nbsp;</a></span>Debug()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Debug </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this class method with a value greater than zero to enable debug messages, or with zero to disable messages. Calling with no arguments returns true if debugging enabled, else false. </p>

</div>
</div>
<a id="ac749628a10c09afa9593c4315d9d1a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac749628a10c09afa9593c4315d9d1a75">&#9670;&nbsp;</a></span>nNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::nNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of nodes (one more than the number of intervals). </p>

</div>
</div>
<a id="aa348e90f54e237276bf0947da927cd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa348e90f54e237276bf0947da927cd24">&#9670;&nbsp;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::nodes </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return array of the node coordinates. Returns 0 if not <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a>. The array of nodes returned by <a class="el" href="classBSplineBase.html#aa348e90f54e237276bf0947da927cd24">nodes()</a> belongs to the object and should not be deleted; it will also be invalid if the object is destroyed. </p>

</div>
</div>
<a id="a7b6a533b72487d286fe610882db05528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6a533b72487d286fe610882db05528">&#9670;&nbsp;</a></span>nX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::nX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of original x values. </p>

</div>
</div>
<a id="aa1cd42e86d06c2fcd56d422cca33ec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cd42e86d06c2fcd56d422cca33ec54">&#9670;&nbsp;</a></span>ok()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::ok </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the current state of the object, either ok or not ok. Use this method to test for valid state after construction or after a call to <a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f">setDomain()</a>. <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a> will return false if either fail, such as when an appropriate number of nodes and node interval cannot be found for a given wavelength, or when the linear equation for the coefficients cannot be solved. </p>

</div>
</div>
<a id="a86ccf8bcfd237d1d2f663ee755c06c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ccf8bcfd237d1d2f663ee755c06c39">&#9670;&nbsp;</a></span>qDelta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::qDelta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the integral of the product of the basis function derivative restricted to the node domain, 0 to M. </p>

</div>
</div>
<a id="acf18fd5d8fd0c0723fe8ef688a9d220f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf18fd5d8fd0c0723fe8ef688a9d220f">&#9670;&nbsp;</a></span>setDomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::setDomain </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bc_type</em> = <code><a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bbabe606d289277b3422eb8928803f55dbd">BC_ZERO_SECOND</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the domain of this base. [If this is part of a <a class="el" href="classBSpline.html">BSpline</a> object, this method {<em>will</em> not} change the existing curve or re-apply the smoothing to any set of y values.]</p>
<p>The x values can be in any order, but they must be of sufficient density to support the requested cutoff wavelength. The setup of the domain may fail because of either inconsistency between the x density and the cutoff wavelength, or because the resulting matrix could not be factored. If setup fails, the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The array of x values in the domain. </td></tr>
    <tr><td class="paramname">nx</td><td>The number of values in the <code>x</code> array. </td></tr>
    <tr><td class="paramname">wl</td><td>The cutoff wavelength, in the same units as the <code>x</code> values. A wavelength of zero disables the derivative constraint. </td></tr>
    <tr><td class="paramname">bc_type</td><td>The enumerated boundary condition type. If omitted it defaults to BC_ZERO_SECOND. </td></tr>
    <tr><td class="paramname">num_nodes</td><td>The number of nodes to use for the cubic b-spline. If less than 2 a reasonable number will be calculated automatically, if possible, taking into account the given cutoff wavelength.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok()</a>. </dd></dl>

</div>
</div>
<a id="a8910fa43321182d1dbc192422f0d7518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8910fa43321182d1dbc192422f0d7518">&#9670;&nbsp;</a></span>Setup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Setup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup number of nodes and deltax for the given domain and cutoff wavelength. </p>
<p>According to Ooyama, the derivative constraint approximates a lo-pass filter if the cutoff wavelength is about 4*deltax or more, but it should at least be 2*deltax. We can increase the number of nodes to increase the number of nodes per cutoff wavelength. However, to get a reasonable representation of the data, the setup enforces at least as many nodes as data points in the domain. (This constraint assumes reasonably even distribution of data points, since its really the density of data points which matters.)</p>
<p>Return zero if the setup fails, non-zero otherwise.</p>
<p>The algorithm in this routine is mostly taken from the FORTRAN implementation by James Franklin, NOAA/HRD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_nodes</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7857ee42bae59319f95a7baca5be814e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7857ee42bae59319f95a7baca5be814e">&#9670;&nbsp;</a></span>BoundaryConditions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::BoundaryConditions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">{</div>
<div class="line">    </div>
<div class="line">    {  -4,  -1,   -1,  -4 },</div>
<div class="line">    {   0,   1,    1,   0 },</div>
<div class="line">    {   2,  -1,   -1,   2 }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This array contains the beta parameter for the boundary condition constraints. The boundary condition type&ndash;0, 1, or 2&ndash;is the first index into the array, followed by the index of the endpoints. See the <a class="el" href="classBSplineBase.html#a5ae444b1b403cf909503985d6e00cc1a">Beta()</a> method. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>BSpline/<a class="el" href="BSplineBase_8h_source.html">BSplineBase.h</a></li>
<li>BSpline/BSplineBase.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
